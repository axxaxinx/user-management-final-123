{"ast":null,"code":"import { HttpResponse, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { delay, materialize, dematerialize } from 'rxjs/operators';\nimport { Role } from '../_models';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../_services\";\n// array in local storage for accounts\nconst accountsKey = 'angular-19-boilerplate-accounts';\nlet accounts = JSON.parse(localStorage.getItem(accountsKey) ?? '[]');\nconst departmentsKey = 'departments';\nlet departments = JSON.parse(localStorage.getItem(departmentsKey) ?? '[]');\nconst employeesKey = 'employees';\nlet employees = JSON.parse(localStorage.getItem(employeesKey) ?? '[]');\nconst workflowsKey = 'workflows';\nlet workflows = JSON.parse(localStorage.getItem(workflowsKey) ?? '[]');\nexport let FakeBackendInterceptor = /*#__PURE__*/(() => {\n  class FakeBackendInterceptor {\n    alertService;\n    constructor(alertService) {\n      this.alertService = alertService;\n    }\n    intercept(request, next) {\n      const {\n        url,\n        method,\n        headers,\n        body\n      } = request;\n      const alertService = this.alertService;\n      return handleRoute();\n      function handleRoute() {\n        switch (true) {\n          case url.endsWith('/accounts/authenticate') && method === 'POST':\n            return authenticate();\n          case url.endsWith('/accounts/refresh-token') && method === 'POST':\n            return refreshToken();\n          case url.endsWith('/accounts/revoke-token') && method === 'POST':\n            return revokeToken();\n          case url.endsWith('/accounts/register') && method === 'POST':\n            return register();\n          case url.endsWith('/accounts/verify-email') && method === 'POST':\n            return verifyEmail();\n          case url.endsWith('/accounts/forgot-password') && method === 'POST':\n            return forgotPassword();\n          case url.endsWith('/accounts/validate-reset-token') && method === 'POST':\n            return validateResetToken();\n          case url.endsWith('/accounts/reset-password') && method === 'POST':\n            return resetPassword();\n          case url.endsWith('/accounts') && method === 'GET':\n            return getAccounts();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'GET':\n            return getAccountById();\n          case url.endsWith('/accounts') && method === 'POST':\n            return createAccount();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'PUT':\n            return updateAccount();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'DELETE':\n            return deleteAccount();\n          // --- START NEW PUBLIC ROUTE ---\n          case url.endsWith('/accounts/all') && method === 'GET':\n            // Public GET all\n            return getAllAccountsPublic();\n          // --- END NEW PUBLIC ROUTE ---\n          case url.endsWith('/employees') && method === 'GET':\n            return getEmployees();\n          case url.match(/\\/employees\\/\\d+$/) && method === 'GET':\n            return getEmployeeById(url);\n          case url.endsWith('/employees') && method === 'POST':\n            return createEmployee(body);\n          case url.match(/\\/employees\\/\\d+$/) && method === 'PUT':\n            return updateEmployee(url, body);\n          case url.match(/\\/employees\\/\\d+$/) && method === 'DELETE':\n            return deleteEmployee(url);\n          case url.endsWith('/departments') && method === 'GET':\n            return getDepartments();\n          case url.match(/\\/departments\\/\\d+$/) && method === 'GET':\n            return getDepartmentById(url);\n          case url.endsWith('/departments') && method === 'POST':\n            return createDepartment(body);\n          case url.match(/\\/departments\\/\\d+$/) && method === 'PUT':\n            return updateDepartment(url, body);\n          case url.match(/\\/departments\\/\\d+$/) && method === 'DELETE':\n            return deleteDepartment(url);\n          case url.match(/\\/workflows\\/employee\\/\\d+$/) && method === 'GET':\n            return getWorkflowsByEmployeeId(url);\n          case url.endsWith('/workflows') && method === 'POST':\n            return createWorkflow(body);\n          case url.match(/\\/workflows\\/\\d+\\/status$/) && method === 'PUT':\n            return updateWorkflowStatus(url, body);\n          default:\n            // pass through any requests not handled above\n            return next.handle(request);\n        }\n      }\n      // route functions\n      function authenticate() {\n        const {\n          email,\n          password\n        } = body;\n        // const account = accounts.find(x => x.email === email && x.password === password && x.isVerified);\n        // if (!account) return error('Email or password is incorrect');\n        let account = accounts.find(x => x.email === email);\n        if (account.id !== 1) {\n          if (!account) return error('Email does not exist');\n          if (!account || account.password !== password) return error('Password is incorrect');\n          if (!account.isVerified) {\n            // display verification email in alert\n            setTimeout(() => {\n              const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\n              alertService.info(`\n                            <h4>Verification Email</h4>\n                            <p>Please click the below link to verify your email address:</p>\n                            <p><a href=\"${verifyUrl}\">${verifyUrl}</a></p>\n                        `, {\n                autoClose: false\n              });\n            }, 5000);\n            return error('Email is not verified');\n          }\n          if (!account || account.status !== 'Active') return error('Account is InActive. Please contact system administrator!');\n        }\n        // add refresh token to account\n        account.refreshTokens.push(generateRefreshToken());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok({\n          ...basicDetails(account),\n          jwtToken: generateJwtToken(account)\n        });\n      }\n      function refreshToken() {\n        const refreshToken = getRefreshToken();\n        if (!refreshToken) return unauthorized();\n        const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n        if (!account) return unauthorized();\n        // replace old refresh token with a new one and save\n        account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n        account.refreshTokens.push(generateRefreshToken());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok({\n          ...basicDetails(account),\n          jwtToken: generateJwtToken(account)\n        });\n      }\n      function revokeToken() {\n        if (!isAuthenticated()) return unauthorized();\n        const refreshToken = getRefreshToken();\n        const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n        // revoke token and save\n        account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function register() {\n        const account = body;\n        let isFirstUser = false; // Flag to indicate if it's the first user\n        if (accounts.find(x => x.email === account.email)) {\n          // display email already registered \"email\" in alert\n          setTimeout(() => {\n            alertService.info(`\n                        <h4>Email Already Registered</h4>\n                        <p>Your email ${account.email} is already registered.</p>\n                        <p>If you don't know your password please visit the <a href=\"${location.origin}/account/forgot-password\">forgot password</a> page.</p>\n                        <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n                    `, {\n              autoClose: false\n            });\n          }, 1000);\n          // always return ok() response to prevent email enumeration\n          return ok();\n        }\n        // assign account id and a few other properties then save\n        account.id = newAccountId();\n        if (account.id === 1) {\n          // first registered account is an admin\n          account.isVerified = true;\n          account.role = Role.Admin;\n          isFirstUser = true; // Set the flag\n        } else {\n          account.isVerified = false;\n          account.role = Role.User;\n        }\n        account.status = 'InActive';\n        account.dateCreated = new Date().toISOString();\n        account.verificationToken = new Date().getTime().toString();\n        account.refreshTokens = [];\n        delete account.confirmPassword;\n        accounts.push(account);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        if (isFirstUser) {\n          setTimeout(() => {\n            alertService.info(`\n                        <h4>First User Login</h4>\n                        <p>You can login directly as first user where role is Admin and account is verified</p>\n                        <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n                    `, {\n              autoClose: false\n            });\n          }, 1000);\n        } else {\n          // display verification email in alert\n          setTimeout(() => {\n            const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\n            alertService.info(`\n                        <h4>Verification Email</h4>\n                        <p>Thanks for registering!</p>\n                        <p>Please click the below link to verify your email address:</p>\n                        <p><a href=\"${verifyUrl}\">${verifyUrl}</a></p>\n                        <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n                    `, {\n              autoClose: false\n            });\n          }, 1000);\n        }\n        // Return ok status with a flag indicating if it was the first user\n        return ok({\n          isFirstUser: isFirstUser\n        });\n      }\n      function verifyEmail() {\n        const {\n          token\n        } = body;\n        const account = accounts.find(x => !!x.verificationToken && x.verificationToken === token);\n        if (!account) return error('Verification failed');\n        // set is verified flag to true if token is valid\n        account.isVerified = true;\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function forgotPassword() {\n        const {\n          email\n        } = body;\n        const account = accounts.find(x => x.email === email);\n        // always return ok() response to prevent email enumeration\n        if (!account) return ok();\n        // create reset token that expires after 24 hours\n        account.resetToken = new Date().getTime().toString();\n        account.resetTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        // display password reset email in alert\n        setTimeout(() => {\n          const resetUrl = `${location.origin}/account/reset-password?token=${account.resetToken}`;\n          alertService.info(`\n                    <h4>Reset Password Email</h4>\n                    <p>Please click the below link to reset your password, the link will be valid for 1 day:</p>\n                    <p><a href=\"${resetUrl}\">${resetUrl}</a></p>\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n                `, {\n            autoClose: false\n          });\n        }, 1000);\n        return ok();\n      }\n      function validateResetToken() {\n        const {\n          token\n        } = body;\n        const account = accounts.find(x => !!x.resetToken && x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n        if (!account) return error('Invalid token');\n        return ok();\n      }\n      function resetPassword() {\n        const {\n          token,\n          password\n        } = body;\n        const account = accounts.find(x => !!x.resetToken && x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n        if (!account) return error('Invalid token');\n        // update password and remove reset token\n        account.password = password;\n        account.isVerified = true;\n        delete account.resetToken;\n        delete account.resetTokenExpires;\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function getAccounts() {\n        if (!isAuthenticated()) return unauthorized();\n        return ok(accounts.map(x => basicDetails(x)));\n      }\n      function getAccountById() {\n        if (!isAuthenticated()) return unauthorized();\n        let account = accounts.find(x => x.id === idFromUrl());\n        // user accounts can get own profile and admin accounts can get all profiles\n        if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        }\n        return ok(basicDetails(account));\n      }\n      function createAccount() {\n        if (!isAuthorized(Role.Admin)) return unauthorized();\n        const account = body;\n        if (accounts.find(x => x.email === account.email)) {\n          return error(`Email ${account.email} is already registered`);\n        }\n        // assign account id and a few other properties then save\n        account.id = newAccountId();\n        account.dateCreated = new Date().toISOString();\n        account.isVerified = true;\n        account.refreshTokens = [];\n        delete account.confirmPassword;\n        accounts.push(account);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function updateAccount() {\n        if (!isAuthenticated()) return unauthorized();\n        let params = body;\n        let account = accounts.find(x => x.id === idFromUrl());\n        // user accounts can update own profile and admin accounts can update all profiles\n        if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        }\n        // only update password if included\n        if (!params.password) {\n          delete params.password;\n        }\n        // don't save confirm password\n        delete params.confirmPassword;\n        // update and save account\n        Object.assign(account, params);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok(basicDetails(account));\n      }\n      function deleteAccount() {\n        if (!isAuthenticated()) return unauthorized();\n        let account = accounts.find(x => x.id === idFromUrl());\n        // user accounts can delete own account and admin accounts can delete any account\n        if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        }\n        // delete account then save\n        accounts = accounts.filter(x => x.id !== idFromUrl());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function getEmployees() {\n        return this.ok(this.employees);\n      }\n      function getEmployeeById(url) {\n        const id = parseInt(url.split('/').pop());\n        const employee = this.employees.find(x => x.id === id);\n        return employee ? this.ok(employee) : this.error('Employee not found');\n      }\n      function createEmployee(body) {\n        const employee = {\n          id: this.employees.length + 1,\n          employeeId: body.employeeId,\n          userId: body.userId,\n          position: body.position,\n          departmentId: body.departmentId,\n          hireDate: body.hireDate,\n          status: 'Active',\n          user: {\n            id: body.userId,\n            email: `user${body.userId}@example.com`\n          },\n          department: this.departments.find(d => d.id === body.departmentId) || {\n            id: body.departmentId,\n            name: 'Unknown'\n          }\n        };\n        this.employees.push(employee);\n        return this.ok(employee);\n      }\n      function updateEmployee(url, body) {\n        const id = parseInt(url.split('/').pop());\n        const employee = this.employees.find(x => x.id === id);\n        if (!employee) return this.error('Employee not found');\n        Object.assign(employee, body);\n        return this.ok(employee);\n      }\n      function deleteEmployee(url) {\n        const id = parseInt(url.split('/').pop());\n        this.employees = this.employees.filter(x => x.id !== id);\n        return this.ok({\n          message: 'Employee deleted successfully'\n        });\n      }\n      function getDepartments() {\n        return ok(departments.map(x => departmentDetails(x)));\n      }\n      function getDepartmentById(url) {\n        const id = parseInt(url.split('/').pop());\n        const department = this.departments.find(x => x.id === id);\n        return department ? this.ok(department) : this.error('Department not found');\n      }\n      function createDepartment(body) {\n        console.log('Creating department:', body);\n        const department = {\n          id: departments.length + 1,\n          name: body.name,\n          description: body.description\n        };\n        departments.push(department);\n        localStorage.setItem(departmentsKey, JSON.stringify(departments));\n        return ok(department);\n      }\n      function updateDepartment(url, body) {\n        const id = parseInt(url.split('/').pop());\n        const department = this.departments.find(x => x.id === id);\n        if (!department) return this.error('Department not found');\n        Object.assign(department, body);\n        return this.ok(department);\n      }\n      function deleteDepartment(url) {\n        const id = parseInt(url.split('/').pop());\n        departments = departments.filter(x => x.id !== id);\n        localStorage.setItem(departmentsKey, JSON.stringify(departments));\n        return ok({\n          message: 'Department deleted successfully'\n        });\n      }\n      function getWorkflowsByEmployeeId(url) {\n        const employeeId = parseInt(url.split('/').pop());\n        const workflows = this.workflows.filter(x => x.employeeId === employeeId);\n        return this.ok(workflows);\n      }\n      function createWorkflow(body) {\n        const workflow = {\n          id: this.workflows.length + 1,\n          employeeId: body.employeeId,\n          type: body.type,\n          status: 'Pending',\n          details: body.details,\n          createdAt: new Date()\n        };\n        this.workflows.push(workflow);\n        return this.ok(workflow);\n      }\n      function updateWorkflowStatus(url, body) {\n        const id = parseInt(url.split('/')[2]);\n        const workflow = this.workflows.find(x => x.id === id);\n        if (!workflow) return this.error('Workflow not found');\n        workflow.status = body.status;\n        return this.ok(workflow);\n      }\n      // helper functions\n      function ok(body) {\n        return of(new HttpResponse({\n          status: 200,\n          body\n        })).pipe(delay(500)); // delay observable to simulate server api call\n      }\n      function error(message) {\n        return throwError({\n          error: {\n            message\n          }\n        }).pipe(materialize(), delay(500), dematerialize());\n        // call materialize and dematerialize to ensure delay even if an error is thrown (https://github.com/Reactive-Extensions/RxJS/issues/648);\n      }\n      function unauthorized() {\n        return throwError({\n          status: 401,\n          error: {\n            message: 'Unauthorized'\n          }\n        }).pipe(materialize(), delay(500), dematerialize());\n      }\n      function basicDetails(account) {\n        const {\n          id,\n          title,\n          firstName,\n          lastName,\n          email,\n          role,\n          dateCreated,\n          isVerified,\n          status\n        } = account;\n        return {\n          id,\n          title,\n          firstName,\n          lastName,\n          email,\n          role,\n          dateCreated,\n          isVerified,\n          status\n        };\n      }\n      function departmentDetails(account) {\n        const {\n          id,\n          name,\n          description\n        } = account;\n        return {\n          id,\n          name,\n          description\n        };\n      }\n      function isAuthenticated() {\n        return !!currentAccount();\n      }\n      function isAuthorized(role) {\n        const account = currentAccount();\n        if (!account) return false;\n        return account.role === role;\n      }\n      function idFromUrl() {\n        const urlParts = url.split('/');\n        return parseInt(urlParts[urlParts.length - 1]);\n      }\n      function newAccountId() {\n        return accounts.length ? Math.max(...accounts.map(x => x.id)) + 1 : 1;\n      }\n      function currentAccount() {\n        // check if jwt token is in auth header\n        const authHeader = headers.get('Authorization');\n        if (!authHeader || !authHeader.startsWith('Bearer fake-jwt-token')) return;\n        // check if token is expired\n        // const tokenParts = authHeader.split('.');\n        // if (tokenParts.length < 2) return;\n        // const jwtToken = JSON.parse(atob(tokenParts[1]));\n        // const tokenExpired = Date.now() > (jwtToken.exp * 1000);  \n        // if (tokenExpired) return;\n        // const account = accounts.find(x => x.id === jwtToken.id);\n        // return account;\n        const tokenParts = authHeader.split('.');\n        if (tokenParts.length < 2) return undefined; // Return undefined for clarity\n        try {\n          const jwtToken = JSON.parse(atob(tokenParts[1]));\n          const tokenExpired = Date.now() > jwtToken.exp * 1000;\n          if (tokenExpired) return undefined; // Return undefined for clarity\n          const account = accounts.find(x => x.id === jwtToken.id);\n          return account;\n        } catch (e) {\n          // Handle potential errors during token parsing (e.g., invalid base64)\n          console.error(\"Error parsing JWT token:\", e);\n          return undefined;\n        }\n      }\n      function generateJwtToken(account) {\n        // create token that expires in 15 minutes\n        const tokenPayload = {\n          exp: Math.round(new Date(Date.now() + 15 * 60 * 1000).getTime() / 1000),\n          id: account.id\n        };\n        return `fake-jwt-token.${btoa(JSON.stringify(tokenPayload))}`;\n      }\n      function generateRefreshToken() {\n        const token = new Date().getTime().toString();\n        // add token cookie that expires in 7 days\n        const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toUTCString();\n        document.cookie = `fakeRefreshToken=${token}; expires=${expires}; path=/`;\n        return token;\n      }\n      function getRefreshToken() {\n        // get refresh token from cookie\n        // return (document.cookie.split(';').find(x => x.includes('fakeRefreshToken')) || '=').split('=')[1];\n        const cookies = document.cookie.split('; ');\n        const refreshTokenCookie = cookies.find(row => row.startsWith('fakeRefreshToken='));\n        return refreshTokenCookie ? refreshTokenCookie.split('=')[1] : '';\n      }\n      // --- START NEW PUBLIC HANDLER FUNCTION ---\n      function getAllAccountsPublic() {\n        // No authentication check needed for this public route.\n        // Return basic details only to avoid exposing sensitive info like passwords/tokens.\n        return ok(accounts.map(x => basicDetails(x)));\n      }\n      // --- END NEW PUBLIC HANDLER FUNCTION ---\n    }\n    static ɵfac = function FakeBackendInterceptor_Factory(t) {\n      return new (t || FakeBackendInterceptor)(i0.ɵɵinject(i1.AlertService));\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: FakeBackendInterceptor,\n      factory: FakeBackendInterceptor.ɵfac\n    });\n  }\n  return FakeBackendInterceptor;\n})();\nexport let fakeBackendProvider = {\n  // use fake backend in place of Http service for backend-less development\n  provide: HTTP_INTERCEPTORS,\n  useClass: FakeBackendInterceptor,\n  multi: true\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}